// Code generated by Prisma (prisma@1.28.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  education: (where?: EducationWhereInput) => Promise<boolean>;
  general: (where?: GeneralWhereInput) => Promise<boolean>;
  hobby: (where?: HobbyWhereInput) => Promise<boolean>;
  job: (where?: JobWhereInput) => Promise<boolean>;
  language: (where?: LanguageWhereInput) => Promise<boolean>;
  resume: (where?: ResumeWhereInput) => Promise<boolean>;
  skill: (where?: SkillWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  educations: (
    args?: {
      where?: EducationWhereInput;
      orderBy?: EducationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Education>;
  educationsConnection: (
    args?: {
      where?: EducationWhereInput;
      orderBy?: EducationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EducationConnectionPromise;
  generals: (
    args?: {
      where?: GeneralWhereInput;
      orderBy?: GeneralOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<General>;
  generalsConnection: (
    args?: {
      where?: GeneralWhereInput;
      orderBy?: GeneralOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GeneralConnectionPromise;
  hobbies: (
    args?: {
      where?: HobbyWhereInput;
      orderBy?: HobbyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Hobby>;
  hobbiesConnection: (
    args?: {
      where?: HobbyWhereInput;
      orderBy?: HobbyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HobbyConnectionPromise;
  jobs: (
    args?: {
      where?: JobWhereInput;
      orderBy?: JobOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Job>;
  jobsConnection: (
    args?: {
      where?: JobWhereInput;
      orderBy?: JobOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => JobConnectionPromise;
  languages: (
    args?: {
      where?: LanguageWhereInput;
      orderBy?: LanguageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Language>;
  languagesConnection: (
    args?: {
      where?: LanguageWhereInput;
      orderBy?: LanguageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LanguageConnectionPromise;
  resume: (where: ResumeWhereUniqueInput) => ResumePromise;
  resumes: (
    args?: {
      where?: ResumeWhereInput;
      orderBy?: ResumeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Resume>;
  resumesConnection: (
    args?: {
      where?: ResumeWhereInput;
      orderBy?: ResumeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ResumeConnectionPromise;
  skills: (
    args?: {
      where?: SkillWhereInput;
      orderBy?: SkillOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Skill>;
  skillsConnection: (
    args?: {
      where?: SkillWhereInput;
      orderBy?: SkillOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SkillConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createEducation: (data: EducationCreateInput) => EducationPromise;
  updateManyEducations: (
    args: {
      data: EducationUpdateManyMutationInput;
      where?: EducationWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyEducations: (where?: EducationWhereInput) => BatchPayloadPromise;
  createGeneral: (data: GeneralCreateInput) => GeneralPromise;
  updateManyGenerals: (
    args: { data: GeneralUpdateManyMutationInput; where?: GeneralWhereInput }
  ) => BatchPayloadPromise;
  deleteManyGenerals: (where?: GeneralWhereInput) => BatchPayloadPromise;
  createHobby: (data: HobbyCreateInput) => HobbyPromise;
  updateManyHobbies: (
    args: { data: HobbyUpdateManyMutationInput; where?: HobbyWhereInput }
  ) => BatchPayloadPromise;
  deleteManyHobbies: (where?: HobbyWhereInput) => BatchPayloadPromise;
  createJob: (data: JobCreateInput) => JobPromise;
  updateManyJobs: (
    args: { data: JobUpdateManyMutationInput; where?: JobWhereInput }
  ) => BatchPayloadPromise;
  deleteManyJobs: (where?: JobWhereInput) => BatchPayloadPromise;
  createLanguage: (data: LanguageCreateInput) => LanguagePromise;
  updateManyLanguages: (
    args: { data: LanguageUpdateManyMutationInput; where?: LanguageWhereInput }
  ) => BatchPayloadPromise;
  deleteManyLanguages: (where?: LanguageWhereInput) => BatchPayloadPromise;
  createResume: (data: ResumeCreateInput) => ResumePromise;
  updateResume: (
    args: { data: ResumeUpdateInput; where: ResumeWhereUniqueInput }
  ) => ResumePromise;
  updateManyResumes: (
    args: { data: ResumeUpdateManyMutationInput; where?: ResumeWhereInput }
  ) => BatchPayloadPromise;
  upsertResume: (
    args: {
      where: ResumeWhereUniqueInput;
      create: ResumeCreateInput;
      update: ResumeUpdateInput;
    }
  ) => ResumePromise;
  deleteResume: (where: ResumeWhereUniqueInput) => ResumePromise;
  deleteManyResumes: (where?: ResumeWhereInput) => BatchPayloadPromise;
  createSkill: (data: SkillCreateInput) => SkillPromise;
  updateManySkills: (
    args: { data: SkillUpdateManyMutationInput; where?: SkillWhereInput }
  ) => BatchPayloadPromise;
  deleteManySkills: (where?: SkillWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  education: (
    where?: EducationSubscriptionWhereInput
  ) => EducationSubscriptionPayloadSubscription;
  general: (
    where?: GeneralSubscriptionWhereInput
  ) => GeneralSubscriptionPayloadSubscription;
  hobby: (
    where?: HobbySubscriptionWhereInput
  ) => HobbySubscriptionPayloadSubscription;
  job: (
    where?: JobSubscriptionWhereInput
  ) => JobSubscriptionPayloadSubscription;
  language: (
    where?: LanguageSubscriptionWhereInput
  ) => LanguageSubscriptionPayloadSubscription;
  resume: (
    where?: ResumeSubscriptionWhereInput
  ) => ResumeSubscriptionPayloadSubscription;
  skill: (
    where?: SkillSubscriptionWhereInput
  ) => SkillSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type EducationOrderByInput =
  | "fieldOfStudy_ASC"
  | "fieldOfStudy_DESC"
  | "dateEnded_ASC"
  | "dateEnded_DESC"
  | "name_ASC"
  | "name_DESC"
  | "location_ASC"
  | "location_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GeneralOrderByInput =
  | "github_ASC"
  | "github_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "address_ASC"
  | "address_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "email_ASC"
  | "email_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HobbyOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "link_ASC"
  | "link_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type JobOrderByInput =
  | "position_ASC"
  | "position_DESC"
  | "company_ASC"
  | "company_DESC"
  | "location_ASC"
  | "location_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LanguageOrderByInput =
  | "language_ASC"
  | "language_DESC"
  | "level_ASC"
  | "level_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SkillOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "level_ASC"
  | "level_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ResumeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "urlSlug_ASC"
  | "urlSlug_DESC"
  | "themeColor_ASC"
  | "themeColor_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface EducationWhereInput {
  fieldOfStudy?: String;
  fieldOfStudy_not?: String;
  fieldOfStudy_in?: String[] | String;
  fieldOfStudy_not_in?: String[] | String;
  fieldOfStudy_lt?: String;
  fieldOfStudy_lte?: String;
  fieldOfStudy_gt?: String;
  fieldOfStudy_gte?: String;
  fieldOfStudy_contains?: String;
  fieldOfStudy_not_contains?: String;
  fieldOfStudy_starts_with?: String;
  fieldOfStudy_not_starts_with?: String;
  fieldOfStudy_ends_with?: String;
  fieldOfStudy_not_ends_with?: String;
  dateEnded?: String;
  dateEnded_not?: String;
  dateEnded_in?: String[] | String;
  dateEnded_not_in?: String[] | String;
  dateEnded_lt?: String;
  dateEnded_lte?: String;
  dateEnded_gt?: String;
  dateEnded_gte?: String;
  dateEnded_contains?: String;
  dateEnded_not_contains?: String;
  dateEnded_starts_with?: String;
  dateEnded_not_starts_with?: String;
  dateEnded_ends_with?: String;
  dateEnded_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  AND?: EducationWhereInput[] | EducationWhereInput;
  OR?: EducationWhereInput[] | EducationWhereInput;
  NOT?: EducationWhereInput[] | EducationWhereInput;
}

export interface GeneralWhereInput {
  github?: String;
  github_not?: String;
  github_in?: String[] | String;
  github_not_in?: String[] | String;
  github_lt?: String;
  github_lte?: String;
  github_gt?: String;
  github_gte?: String;
  github_contains?: String;
  github_not_contains?: String;
  github_starts_with?: String;
  github_not_starts_with?: String;
  github_ends_with?: String;
  github_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  phoneNumber?: String;
  phoneNumber_not?: String;
  phoneNumber_in?: String[] | String;
  phoneNumber_not_in?: String[] | String;
  phoneNumber_lt?: String;
  phoneNumber_lte?: String;
  phoneNumber_gt?: String;
  phoneNumber_gte?: String;
  phoneNumber_contains?: String;
  phoneNumber_not_contains?: String;
  phoneNumber_starts_with?: String;
  phoneNumber_not_starts_with?: String;
  phoneNumber_ends_with?: String;
  phoneNumber_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  AND?: GeneralWhereInput[] | GeneralWhereInput;
  OR?: GeneralWhereInput[] | GeneralWhereInput;
  NOT?: GeneralWhereInput[] | GeneralWhereInput;
}

export interface HobbyWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  icon?: String;
  icon_not?: String;
  icon_in?: String[] | String;
  icon_not_in?: String[] | String;
  icon_lt?: String;
  icon_lte?: String;
  icon_gt?: String;
  icon_gte?: String;
  icon_contains?: String;
  icon_not_contains?: String;
  icon_starts_with?: String;
  icon_not_starts_with?: String;
  icon_ends_with?: String;
  icon_not_ends_with?: String;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  AND?: HobbyWhereInput[] | HobbyWhereInput;
  OR?: HobbyWhereInput[] | HobbyWhereInput;
  NOT?: HobbyWhereInput[] | HobbyWhereInput;
}

export interface JobWhereInput {
  position?: String;
  position_not?: String;
  position_in?: String[] | String;
  position_not_in?: String[] | String;
  position_lt?: String;
  position_lte?: String;
  position_gt?: String;
  position_gte?: String;
  position_contains?: String;
  position_not_contains?: String;
  position_starts_with?: String;
  position_not_starts_with?: String;
  position_ends_with?: String;
  position_not_ends_with?: String;
  company?: String;
  company_not?: String;
  company_in?: String[] | String;
  company_not_in?: String[] | String;
  company_lt?: String;
  company_lte?: String;
  company_gt?: String;
  company_gte?: String;
  company_contains?: String;
  company_not_contains?: String;
  company_starts_with?: String;
  company_not_starts_with?: String;
  company_ends_with?: String;
  company_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  startDate?: String;
  startDate_not?: String;
  startDate_in?: String[] | String;
  startDate_not_in?: String[] | String;
  startDate_lt?: String;
  startDate_lte?: String;
  startDate_gt?: String;
  startDate_gte?: String;
  startDate_contains?: String;
  startDate_not_contains?: String;
  startDate_starts_with?: String;
  startDate_not_starts_with?: String;
  startDate_ends_with?: String;
  startDate_not_ends_with?: String;
  endDate?: String;
  endDate_not?: String;
  endDate_in?: String[] | String;
  endDate_not_in?: String[] | String;
  endDate_lt?: String;
  endDate_lte?: String;
  endDate_gt?: String;
  endDate_gte?: String;
  endDate_contains?: String;
  endDate_not_contains?: String;
  endDate_starts_with?: String;
  endDate_not_starts_with?: String;
  endDate_ends_with?: String;
  endDate_not_ends_with?: String;
  AND?: JobWhereInput[] | JobWhereInput;
  OR?: JobWhereInput[] | JobWhereInput;
  NOT?: JobWhereInput[] | JobWhereInput;
}

export interface LanguageWhereInput {
  language?: String;
  language_not?: String;
  language_in?: String[] | String;
  language_not_in?: String[] | String;
  language_lt?: String;
  language_lte?: String;
  language_gt?: String;
  language_gte?: String;
  language_contains?: String;
  language_not_contains?: String;
  language_starts_with?: String;
  language_not_starts_with?: String;
  language_ends_with?: String;
  language_not_ends_with?: String;
  level?: String;
  level_not?: String;
  level_in?: String[] | String;
  level_not_in?: String[] | String;
  level_lt?: String;
  level_lte?: String;
  level_gt?: String;
  level_gte?: String;
  level_contains?: String;
  level_not_contains?: String;
  level_starts_with?: String;
  level_not_starts_with?: String;
  level_ends_with?: String;
  level_not_ends_with?: String;
  AND?: LanguageWhereInput[] | LanguageWhereInput;
  OR?: LanguageWhereInput[] | LanguageWhereInput;
  NOT?: LanguageWhereInput[] | LanguageWhereInput;
}

export type ResumeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  urlSlug?: String;
}>;

export interface SkillWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  level?: Float;
  level_not?: Float;
  level_in?: Float[] | Float;
  level_not_in?: Float[] | Float;
  level_lt?: Float;
  level_lte?: Float;
  level_gt?: Float;
  level_gte?: Float;
  AND?: SkillWhereInput[] | SkillWhereInput;
  OR?: SkillWhereInput[] | SkillWhereInput;
  NOT?: SkillWhereInput[] | SkillWhereInput;
}

export interface ResumeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  urlSlug?: String;
  urlSlug_not?: String;
  urlSlug_in?: String[] | String;
  urlSlug_not_in?: String[] | String;
  urlSlug_lt?: String;
  urlSlug_lte?: String;
  urlSlug_gt?: String;
  urlSlug_gte?: String;
  urlSlug_contains?: String;
  urlSlug_not_contains?: String;
  urlSlug_starts_with?: String;
  urlSlug_not_starts_with?: String;
  urlSlug_ends_with?: String;
  urlSlug_not_ends_with?: String;
  themeColor?: String;
  themeColor_not?: String;
  themeColor_in?: String[] | String;
  themeColor_not_in?: String[] | String;
  themeColor_lt?: String;
  themeColor_lte?: String;
  themeColor_gt?: String;
  themeColor_gte?: String;
  themeColor_contains?: String;
  themeColor_not_contains?: String;
  themeColor_starts_with?: String;
  themeColor_not_starts_with?: String;
  themeColor_ends_with?: String;
  themeColor_not_ends_with?: String;
  general?: GeneralWhereInput;
  education_every?: EducationWhereInput;
  education_some?: EducationWhereInput;
  education_none?: EducationWhereInput;
  workHistory_every?: JobWhereInput;
  workHistory_some?: JobWhereInput;
  workHistory_none?: JobWhereInput;
  languages_every?: LanguageWhereInput;
  languages_some?: LanguageWhereInput;
  languages_none?: LanguageWhereInput;
  hobbies_every?: HobbyWhereInput;
  hobbies_some?: HobbyWhereInput;
  hobbies_none?: HobbyWhereInput;
  technicalSkills_every?: SkillWhereInput;
  technicalSkills_some?: SkillWhereInput;
  technicalSkills_none?: SkillWhereInput;
  AND?: ResumeWhereInput[] | ResumeWhereInput;
  OR?: ResumeWhereInput[] | ResumeWhereInput;
  NOT?: ResumeWhereInput[] | ResumeWhereInput;
}

export interface EducationCreateInput {
  fieldOfStudy: String;
  dateEnded: String;
  name: String;
  location: String;
}

export interface EducationUpdateManyMutationInput {
  fieldOfStudy?: String;
  dateEnded?: String;
  name?: String;
  location?: String;
}

export interface GeneralCreateInput {
  github: String;
  firstName: String;
  lastName: String;
  address: String;
  phoneNumber: String;
  email: String;
}

export interface GeneralUpdateManyMutationInput {
  github?: String;
  firstName?: String;
  lastName?: String;
  address?: String;
  phoneNumber?: String;
  email?: String;
}

export interface HobbyCreateInput {
  name: String;
  icon: String;
  link?: String;
}

export interface HobbyUpdateManyMutationInput {
  name?: String;
  icon?: String;
  link?: String;
}

export interface JobCreateInput {
  position: String;
  company: String;
  location: String;
  startDate: String;
  endDate: String;
  tasks?: JobCreatetasksInput;
}

export interface JobCreatetasksInput {
  set?: String[] | String;
}

export interface JobUpdateManyMutationInput {
  position?: String;
  company?: String;
  location?: String;
  startDate?: String;
  endDate?: String;
  tasks?: JobUpdatetasksInput;
}

export interface JobUpdatetasksInput {
  set?: String[] | String;
}

export interface LanguageCreateInput {
  language: String;
  level: String;
}

export interface LanguageUpdateManyMutationInput {
  language?: String;
  level?: String;
}

export interface ResumeCreateInput {
  urlSlug: String;
  themeColor: String;
  general: GeneralCreateOneInput;
  education?: EducationCreateManyInput;
  workHistory?: JobCreateManyInput;
  languages?: LanguageCreateManyInput;
  hobbies?: HobbyCreateManyInput;
  technicalSkills?: SkillCreateManyInput;
}

export interface GeneralCreateOneInput {
  create?: GeneralCreateInput;
}

export interface EducationCreateManyInput {
  create?: EducationCreateInput[] | EducationCreateInput;
}

export interface JobCreateManyInput {
  create?: JobCreateInput[] | JobCreateInput;
}

export interface LanguageCreateManyInput {
  create?: LanguageCreateInput[] | LanguageCreateInput;
}

export interface HobbyCreateManyInput {
  create?: HobbyCreateInput[] | HobbyCreateInput;
}

export interface SkillCreateManyInput {
  create?: SkillCreateInput[] | SkillCreateInput;
}

export interface SkillCreateInput {
  name: String;
  level: Float;
}

export interface ResumeUpdateInput {
  urlSlug?: String;
  themeColor?: String;
  general?: GeneralUpdateOneRequiredInput;
  education?: EducationUpdateManyInput;
  workHistory?: JobUpdateManyInput;
  languages?: LanguageUpdateManyInput;
  hobbies?: HobbyUpdateManyInput;
  technicalSkills?: SkillUpdateManyInput;
}

export interface GeneralUpdateOneRequiredInput {
  create?: GeneralCreateInput;
  update?: GeneralUpdateDataInput;
  upsert?: GeneralUpsertNestedInput;
}

export interface GeneralUpdateDataInput {
  github?: String;
  firstName?: String;
  lastName?: String;
  address?: String;
  phoneNumber?: String;
  email?: String;
}

export interface GeneralUpsertNestedInput {
  update: GeneralUpdateDataInput;
  create: GeneralCreateInput;
}

export interface EducationUpdateManyInput {
  create?: EducationCreateInput[] | EducationCreateInput;
  deleteMany?: EducationScalarWhereInput[] | EducationScalarWhereInput;
  updateMany?:
    | EducationUpdateManyWithWhereNestedInput[]
    | EducationUpdateManyWithWhereNestedInput;
}

export interface EducationScalarWhereInput {
  fieldOfStudy?: String;
  fieldOfStudy_not?: String;
  fieldOfStudy_in?: String[] | String;
  fieldOfStudy_not_in?: String[] | String;
  fieldOfStudy_lt?: String;
  fieldOfStudy_lte?: String;
  fieldOfStudy_gt?: String;
  fieldOfStudy_gte?: String;
  fieldOfStudy_contains?: String;
  fieldOfStudy_not_contains?: String;
  fieldOfStudy_starts_with?: String;
  fieldOfStudy_not_starts_with?: String;
  fieldOfStudy_ends_with?: String;
  fieldOfStudy_not_ends_with?: String;
  dateEnded?: String;
  dateEnded_not?: String;
  dateEnded_in?: String[] | String;
  dateEnded_not_in?: String[] | String;
  dateEnded_lt?: String;
  dateEnded_lte?: String;
  dateEnded_gt?: String;
  dateEnded_gte?: String;
  dateEnded_contains?: String;
  dateEnded_not_contains?: String;
  dateEnded_starts_with?: String;
  dateEnded_not_starts_with?: String;
  dateEnded_ends_with?: String;
  dateEnded_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  AND?: EducationScalarWhereInput[] | EducationScalarWhereInput;
  OR?: EducationScalarWhereInput[] | EducationScalarWhereInput;
  NOT?: EducationScalarWhereInput[] | EducationScalarWhereInput;
}

export interface EducationUpdateManyWithWhereNestedInput {
  where: EducationScalarWhereInput;
  data: EducationUpdateManyDataInput;
}

export interface EducationUpdateManyDataInput {
  fieldOfStudy?: String;
  dateEnded?: String;
  name?: String;
  location?: String;
}

export interface JobUpdateManyInput {
  create?: JobCreateInput[] | JobCreateInput;
  deleteMany?: JobScalarWhereInput[] | JobScalarWhereInput;
  updateMany?:
    | JobUpdateManyWithWhereNestedInput[]
    | JobUpdateManyWithWhereNestedInput;
}

export interface JobScalarWhereInput {
  position?: String;
  position_not?: String;
  position_in?: String[] | String;
  position_not_in?: String[] | String;
  position_lt?: String;
  position_lte?: String;
  position_gt?: String;
  position_gte?: String;
  position_contains?: String;
  position_not_contains?: String;
  position_starts_with?: String;
  position_not_starts_with?: String;
  position_ends_with?: String;
  position_not_ends_with?: String;
  company?: String;
  company_not?: String;
  company_in?: String[] | String;
  company_not_in?: String[] | String;
  company_lt?: String;
  company_lte?: String;
  company_gt?: String;
  company_gte?: String;
  company_contains?: String;
  company_not_contains?: String;
  company_starts_with?: String;
  company_not_starts_with?: String;
  company_ends_with?: String;
  company_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  startDate?: String;
  startDate_not?: String;
  startDate_in?: String[] | String;
  startDate_not_in?: String[] | String;
  startDate_lt?: String;
  startDate_lte?: String;
  startDate_gt?: String;
  startDate_gte?: String;
  startDate_contains?: String;
  startDate_not_contains?: String;
  startDate_starts_with?: String;
  startDate_not_starts_with?: String;
  startDate_ends_with?: String;
  startDate_not_ends_with?: String;
  endDate?: String;
  endDate_not?: String;
  endDate_in?: String[] | String;
  endDate_not_in?: String[] | String;
  endDate_lt?: String;
  endDate_lte?: String;
  endDate_gt?: String;
  endDate_gte?: String;
  endDate_contains?: String;
  endDate_not_contains?: String;
  endDate_starts_with?: String;
  endDate_not_starts_with?: String;
  endDate_ends_with?: String;
  endDate_not_ends_with?: String;
  AND?: JobScalarWhereInput[] | JobScalarWhereInput;
  OR?: JobScalarWhereInput[] | JobScalarWhereInput;
  NOT?: JobScalarWhereInput[] | JobScalarWhereInput;
}

export interface JobUpdateManyWithWhereNestedInput {
  where: JobScalarWhereInput;
  data: JobUpdateManyDataInput;
}

export interface JobUpdateManyDataInput {
  position?: String;
  company?: String;
  location?: String;
  startDate?: String;
  endDate?: String;
  tasks?: JobUpdatetasksInput;
}

export interface LanguageUpdateManyInput {
  create?: LanguageCreateInput[] | LanguageCreateInput;
  deleteMany?: LanguageScalarWhereInput[] | LanguageScalarWhereInput;
  updateMany?:
    | LanguageUpdateManyWithWhereNestedInput[]
    | LanguageUpdateManyWithWhereNestedInput;
}

export interface LanguageScalarWhereInput {
  language?: String;
  language_not?: String;
  language_in?: String[] | String;
  language_not_in?: String[] | String;
  language_lt?: String;
  language_lte?: String;
  language_gt?: String;
  language_gte?: String;
  language_contains?: String;
  language_not_contains?: String;
  language_starts_with?: String;
  language_not_starts_with?: String;
  language_ends_with?: String;
  language_not_ends_with?: String;
  level?: String;
  level_not?: String;
  level_in?: String[] | String;
  level_not_in?: String[] | String;
  level_lt?: String;
  level_lte?: String;
  level_gt?: String;
  level_gte?: String;
  level_contains?: String;
  level_not_contains?: String;
  level_starts_with?: String;
  level_not_starts_with?: String;
  level_ends_with?: String;
  level_not_ends_with?: String;
  AND?: LanguageScalarWhereInput[] | LanguageScalarWhereInput;
  OR?: LanguageScalarWhereInput[] | LanguageScalarWhereInput;
  NOT?: LanguageScalarWhereInput[] | LanguageScalarWhereInput;
}

export interface LanguageUpdateManyWithWhereNestedInput {
  where: LanguageScalarWhereInput;
  data: LanguageUpdateManyDataInput;
}

export interface LanguageUpdateManyDataInput {
  language?: String;
  level?: String;
}

export interface HobbyUpdateManyInput {
  create?: HobbyCreateInput[] | HobbyCreateInput;
  deleteMany?: HobbyScalarWhereInput[] | HobbyScalarWhereInput;
  updateMany?:
    | HobbyUpdateManyWithWhereNestedInput[]
    | HobbyUpdateManyWithWhereNestedInput;
}

export interface HobbyScalarWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  icon?: String;
  icon_not?: String;
  icon_in?: String[] | String;
  icon_not_in?: String[] | String;
  icon_lt?: String;
  icon_lte?: String;
  icon_gt?: String;
  icon_gte?: String;
  icon_contains?: String;
  icon_not_contains?: String;
  icon_starts_with?: String;
  icon_not_starts_with?: String;
  icon_ends_with?: String;
  icon_not_ends_with?: String;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  AND?: HobbyScalarWhereInput[] | HobbyScalarWhereInput;
  OR?: HobbyScalarWhereInput[] | HobbyScalarWhereInput;
  NOT?: HobbyScalarWhereInput[] | HobbyScalarWhereInput;
}

export interface HobbyUpdateManyWithWhereNestedInput {
  where: HobbyScalarWhereInput;
  data: HobbyUpdateManyDataInput;
}

export interface HobbyUpdateManyDataInput {
  name?: String;
  icon?: String;
  link?: String;
}

export interface SkillUpdateManyInput {
  create?: SkillCreateInput[] | SkillCreateInput;
  deleteMany?: SkillScalarWhereInput[] | SkillScalarWhereInput;
  updateMany?:
    | SkillUpdateManyWithWhereNestedInput[]
    | SkillUpdateManyWithWhereNestedInput;
}

export interface SkillScalarWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  level?: Float;
  level_not?: Float;
  level_in?: Float[] | Float;
  level_not_in?: Float[] | Float;
  level_lt?: Float;
  level_lte?: Float;
  level_gt?: Float;
  level_gte?: Float;
  AND?: SkillScalarWhereInput[] | SkillScalarWhereInput;
  OR?: SkillScalarWhereInput[] | SkillScalarWhereInput;
  NOT?: SkillScalarWhereInput[] | SkillScalarWhereInput;
}

export interface SkillUpdateManyWithWhereNestedInput {
  where: SkillScalarWhereInput;
  data: SkillUpdateManyDataInput;
}

export interface SkillUpdateManyDataInput {
  name?: String;
  level?: Float;
}

export interface ResumeUpdateManyMutationInput {
  urlSlug?: String;
  themeColor?: String;
}

export interface SkillUpdateManyMutationInput {
  name?: String;
  level?: Float;
}

export interface EducationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EducationWhereInput;
  AND?: EducationSubscriptionWhereInput[] | EducationSubscriptionWhereInput;
  OR?: EducationSubscriptionWhereInput[] | EducationSubscriptionWhereInput;
  NOT?: EducationSubscriptionWhereInput[] | EducationSubscriptionWhereInput;
}

export interface GeneralSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GeneralWhereInput;
  AND?: GeneralSubscriptionWhereInput[] | GeneralSubscriptionWhereInput;
  OR?: GeneralSubscriptionWhereInput[] | GeneralSubscriptionWhereInput;
  NOT?: GeneralSubscriptionWhereInput[] | GeneralSubscriptionWhereInput;
}

export interface HobbySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HobbyWhereInput;
  AND?: HobbySubscriptionWhereInput[] | HobbySubscriptionWhereInput;
  OR?: HobbySubscriptionWhereInput[] | HobbySubscriptionWhereInput;
  NOT?: HobbySubscriptionWhereInput[] | HobbySubscriptionWhereInput;
}

export interface JobSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: JobWhereInput;
  AND?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
  OR?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
  NOT?: JobSubscriptionWhereInput[] | JobSubscriptionWhereInput;
}

export interface LanguageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LanguageWhereInput;
  AND?: LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput;
  OR?: LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput;
  NOT?: LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput;
}

export interface ResumeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ResumeWhereInput;
  AND?: ResumeSubscriptionWhereInput[] | ResumeSubscriptionWhereInput;
  OR?: ResumeSubscriptionWhereInput[] | ResumeSubscriptionWhereInput;
  NOT?: ResumeSubscriptionWhereInput[] | ResumeSubscriptionWhereInput;
}

export interface SkillSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SkillWhereInput;
  AND?: SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput;
  OR?: SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput;
  NOT?: SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Education {
  fieldOfStudy: String;
  dateEnded: String;
  name: String;
  location: String;
}

export interface EducationPromise extends Promise<Education>, Fragmentable {
  fieldOfStudy: () => Promise<String>;
  dateEnded: () => Promise<String>;
  name: () => Promise<String>;
  location: () => Promise<String>;
}

export interface EducationSubscription
  extends Promise<AsyncIterator<Education>>,
    Fragmentable {
  fieldOfStudy: () => Promise<AsyncIterator<String>>;
  dateEnded: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
}

export interface EducationConnection {
  pageInfo: PageInfo;
  edges: EducationEdge[];
}

export interface EducationConnectionPromise
  extends Promise<EducationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EducationEdge>>() => T;
  aggregate: <T = AggregateEducationPromise>() => T;
}

export interface EducationConnectionSubscription
  extends Promise<AsyncIterator<EducationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EducationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEducationSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface EducationEdge {
  node: Education;
  cursor: String;
}

export interface EducationEdgePromise
  extends Promise<EducationEdge>,
    Fragmentable {
  node: <T = EducationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EducationEdgeSubscription
  extends Promise<AsyncIterator<EducationEdge>>,
    Fragmentable {
  node: <T = EducationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEducation {
  count: Int;
}

export interface AggregateEducationPromise
  extends Promise<AggregateEducation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEducationSubscription
  extends Promise<AsyncIterator<AggregateEducation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface General {
  github: String;
  firstName: String;
  lastName: String;
  address: String;
  phoneNumber: String;
  email: String;
}

export interface GeneralPromise extends Promise<General>, Fragmentable {
  github: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  address: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  email: () => Promise<String>;
}

export interface GeneralSubscription
  extends Promise<AsyncIterator<General>>,
    Fragmentable {
  github: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface GeneralConnection {
  pageInfo: PageInfo;
  edges: GeneralEdge[];
}

export interface GeneralConnectionPromise
  extends Promise<GeneralConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GeneralEdge>>() => T;
  aggregate: <T = AggregateGeneralPromise>() => T;
}

export interface GeneralConnectionSubscription
  extends Promise<AsyncIterator<GeneralConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GeneralEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGeneralSubscription>() => T;
}

export interface GeneralEdge {
  node: General;
  cursor: String;
}

export interface GeneralEdgePromise extends Promise<GeneralEdge>, Fragmentable {
  node: <T = GeneralPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GeneralEdgeSubscription
  extends Promise<AsyncIterator<GeneralEdge>>,
    Fragmentable {
  node: <T = GeneralSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGeneral {
  count: Int;
}

export interface AggregateGeneralPromise
  extends Promise<AggregateGeneral>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGeneralSubscription
  extends Promise<AsyncIterator<AggregateGeneral>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Hobby {
  name: String;
  icon: String;
  link?: String;
}

export interface HobbyPromise extends Promise<Hobby>, Fragmentable {
  name: () => Promise<String>;
  icon: () => Promise<String>;
  link: () => Promise<String>;
}

export interface HobbySubscription
  extends Promise<AsyncIterator<Hobby>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface HobbyConnection {
  pageInfo: PageInfo;
  edges: HobbyEdge[];
}

export interface HobbyConnectionPromise
  extends Promise<HobbyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HobbyEdge>>() => T;
  aggregate: <T = AggregateHobbyPromise>() => T;
}

export interface HobbyConnectionSubscription
  extends Promise<AsyncIterator<HobbyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HobbyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHobbySubscription>() => T;
}

export interface HobbyEdge {
  node: Hobby;
  cursor: String;
}

export interface HobbyEdgePromise extends Promise<HobbyEdge>, Fragmentable {
  node: <T = HobbyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HobbyEdgeSubscription
  extends Promise<AsyncIterator<HobbyEdge>>,
    Fragmentable {
  node: <T = HobbySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHobby {
  count: Int;
}

export interface AggregateHobbyPromise
  extends Promise<AggregateHobby>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHobbySubscription
  extends Promise<AsyncIterator<AggregateHobby>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Job {
  position: String;
  company: String;
  location: String;
  startDate: String;
  endDate: String;
  tasks: String[];
}

export interface JobPromise extends Promise<Job>, Fragmentable {
  position: () => Promise<String>;
  company: () => Promise<String>;
  location: () => Promise<String>;
  startDate: () => Promise<String>;
  endDate: () => Promise<String>;
  tasks: () => Promise<String[]>;
}

export interface JobSubscription
  extends Promise<AsyncIterator<Job>>,
    Fragmentable {
  position: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<String>>;
  endDate: () => Promise<AsyncIterator<String>>;
  tasks: () => Promise<AsyncIterator<String[]>>;
}

export interface JobConnection {
  pageInfo: PageInfo;
  edges: JobEdge[];
}

export interface JobConnectionPromise
  extends Promise<JobConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JobEdge>>() => T;
  aggregate: <T = AggregateJobPromise>() => T;
}

export interface JobConnectionSubscription
  extends Promise<AsyncIterator<JobConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JobEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJobSubscription>() => T;
}

export interface JobEdge {
  node: Job;
  cursor: String;
}

export interface JobEdgePromise extends Promise<JobEdge>, Fragmentable {
  node: <T = JobPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JobEdgeSubscription
  extends Promise<AsyncIterator<JobEdge>>,
    Fragmentable {
  node: <T = JobSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateJob {
  count: Int;
}

export interface AggregateJobPromise
  extends Promise<AggregateJob>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJobSubscription
  extends Promise<AsyncIterator<AggregateJob>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Language {
  language: String;
  level: String;
}

export interface LanguagePromise extends Promise<Language>, Fragmentable {
  language: () => Promise<String>;
  level: () => Promise<String>;
}

export interface LanguageSubscription
  extends Promise<AsyncIterator<Language>>,
    Fragmentable {
  language: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<String>>;
}

export interface LanguageConnection {
  pageInfo: PageInfo;
  edges: LanguageEdge[];
}

export interface LanguageConnectionPromise
  extends Promise<LanguageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LanguageEdge>>() => T;
  aggregate: <T = AggregateLanguagePromise>() => T;
}

export interface LanguageConnectionSubscription
  extends Promise<AsyncIterator<LanguageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LanguageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLanguageSubscription>() => T;
}

export interface LanguageEdge {
  node: Language;
  cursor: String;
}

export interface LanguageEdgePromise
  extends Promise<LanguageEdge>,
    Fragmentable {
  node: <T = LanguagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LanguageEdgeSubscription
  extends Promise<AsyncIterator<LanguageEdge>>,
    Fragmentable {
  node: <T = LanguageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLanguage {
  count: Int;
}

export interface AggregateLanguagePromise
  extends Promise<AggregateLanguage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLanguageSubscription
  extends Promise<AsyncIterator<AggregateLanguage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Resume {
  id: ID_Output;
  urlSlug: String;
  themeColor: String;
}

export interface ResumePromise extends Promise<Resume>, Fragmentable {
  id: () => Promise<ID_Output>;
  urlSlug: () => Promise<String>;
  themeColor: () => Promise<String>;
  general: <T = GeneralPromise>() => T;
  education: <T = FragmentableArray<Education>>(
    args?: {
      where?: EducationWhereInput;
      orderBy?: EducationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  workHistory: <T = FragmentableArray<Job>>(
    args?: {
      where?: JobWhereInput;
      orderBy?: JobOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  languages: <T = FragmentableArray<Language>>(
    args?: {
      where?: LanguageWhereInput;
      orderBy?: LanguageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hobbies: <T = FragmentableArray<Hobby>>(
    args?: {
      where?: HobbyWhereInput;
      orderBy?: HobbyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  technicalSkills: <T = FragmentableArray<Skill>>(
    args?: {
      where?: SkillWhereInput;
      orderBy?: SkillOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ResumeSubscription
  extends Promise<AsyncIterator<Resume>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  urlSlug: () => Promise<AsyncIterator<String>>;
  themeColor: () => Promise<AsyncIterator<String>>;
  general: <T = GeneralSubscription>() => T;
  education: <T = Promise<AsyncIterator<EducationSubscription>>>(
    args?: {
      where?: EducationWhereInput;
      orderBy?: EducationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  workHistory: <T = Promise<AsyncIterator<JobSubscription>>>(
    args?: {
      where?: JobWhereInput;
      orderBy?: JobOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  languages: <T = Promise<AsyncIterator<LanguageSubscription>>>(
    args?: {
      where?: LanguageWhereInput;
      orderBy?: LanguageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hobbies: <T = Promise<AsyncIterator<HobbySubscription>>>(
    args?: {
      where?: HobbyWhereInput;
      orderBy?: HobbyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  technicalSkills: <T = Promise<AsyncIterator<SkillSubscription>>>(
    args?: {
      where?: SkillWhereInput;
      orderBy?: SkillOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Skill {
  name: String;
  level: Float;
}

export interface SkillPromise extends Promise<Skill>, Fragmentable {
  name: () => Promise<String>;
  level: () => Promise<Float>;
}

export interface SkillSubscription
  extends Promise<AsyncIterator<Skill>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<Float>>;
}

export interface ResumeConnection {
  pageInfo: PageInfo;
  edges: ResumeEdge[];
}

export interface ResumeConnectionPromise
  extends Promise<ResumeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ResumeEdge>>() => T;
  aggregate: <T = AggregateResumePromise>() => T;
}

export interface ResumeConnectionSubscription
  extends Promise<AsyncIterator<ResumeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ResumeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateResumeSubscription>() => T;
}

export interface ResumeEdge {
  node: Resume;
  cursor: String;
}

export interface ResumeEdgePromise extends Promise<ResumeEdge>, Fragmentable {
  node: <T = ResumePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ResumeEdgeSubscription
  extends Promise<AsyncIterator<ResumeEdge>>,
    Fragmentable {
  node: <T = ResumeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateResume {
  count: Int;
}

export interface AggregateResumePromise
  extends Promise<AggregateResume>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateResumeSubscription
  extends Promise<AsyncIterator<AggregateResume>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SkillConnection {
  pageInfo: PageInfo;
  edges: SkillEdge[];
}

export interface SkillConnectionPromise
  extends Promise<SkillConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SkillEdge>>() => T;
  aggregate: <T = AggregateSkillPromise>() => T;
}

export interface SkillConnectionSubscription
  extends Promise<AsyncIterator<SkillConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SkillEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSkillSubscription>() => T;
}

export interface SkillEdge {
  node: Skill;
  cursor: String;
}

export interface SkillEdgePromise extends Promise<SkillEdge>, Fragmentable {
  node: <T = SkillPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SkillEdgeSubscription
  extends Promise<AsyncIterator<SkillEdge>>,
    Fragmentable {
  node: <T = SkillSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSkill {
  count: Int;
}

export interface AggregateSkillPromise
  extends Promise<AggregateSkill>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSkillSubscription
  extends Promise<AsyncIterator<AggregateSkill>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface EducationSubscriptionPayload {
  mutation: MutationType;
  node: Education;
  updatedFields: String[];
  previousValues: EducationPreviousValues;
}

export interface EducationSubscriptionPayloadPromise
  extends Promise<EducationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EducationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EducationPreviousValuesPromise>() => T;
}

export interface EducationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EducationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EducationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EducationPreviousValuesSubscription>() => T;
}

export interface EducationPreviousValues {
  fieldOfStudy: String;
  dateEnded: String;
  name: String;
  location: String;
}

export interface EducationPreviousValuesPromise
  extends Promise<EducationPreviousValues>,
    Fragmentable {
  fieldOfStudy: () => Promise<String>;
  dateEnded: () => Promise<String>;
  name: () => Promise<String>;
  location: () => Promise<String>;
}

export interface EducationPreviousValuesSubscription
  extends Promise<AsyncIterator<EducationPreviousValues>>,
    Fragmentable {
  fieldOfStudy: () => Promise<AsyncIterator<String>>;
  dateEnded: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
}

export interface GeneralSubscriptionPayload {
  mutation: MutationType;
  node: General;
  updatedFields: String[];
  previousValues: GeneralPreviousValues;
}

export interface GeneralSubscriptionPayloadPromise
  extends Promise<GeneralSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GeneralPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GeneralPreviousValuesPromise>() => T;
}

export interface GeneralSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GeneralSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GeneralSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GeneralPreviousValuesSubscription>() => T;
}

export interface GeneralPreviousValues {
  github: String;
  firstName: String;
  lastName: String;
  address: String;
  phoneNumber: String;
  email: String;
}

export interface GeneralPreviousValuesPromise
  extends Promise<GeneralPreviousValues>,
    Fragmentable {
  github: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  address: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  email: () => Promise<String>;
}

export interface GeneralPreviousValuesSubscription
  extends Promise<AsyncIterator<GeneralPreviousValues>>,
    Fragmentable {
  github: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface HobbySubscriptionPayload {
  mutation: MutationType;
  node: Hobby;
  updatedFields: String[];
  previousValues: HobbyPreviousValues;
}

export interface HobbySubscriptionPayloadPromise
  extends Promise<HobbySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HobbyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HobbyPreviousValuesPromise>() => T;
}

export interface HobbySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HobbySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HobbySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HobbyPreviousValuesSubscription>() => T;
}

export interface HobbyPreviousValues {
  name: String;
  icon: String;
  link?: String;
}

export interface HobbyPreviousValuesPromise
  extends Promise<HobbyPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  icon: () => Promise<String>;
  link: () => Promise<String>;
}

export interface HobbyPreviousValuesSubscription
  extends Promise<AsyncIterator<HobbyPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
}

export interface JobSubscriptionPayload {
  mutation: MutationType;
  node: Job;
  updatedFields: String[];
  previousValues: JobPreviousValues;
}

export interface JobSubscriptionPayloadPromise
  extends Promise<JobSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JobPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JobPreviousValuesPromise>() => T;
}

export interface JobSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JobSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JobSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JobPreviousValuesSubscription>() => T;
}

export interface JobPreviousValues {
  position: String;
  company: String;
  location: String;
  startDate: String;
  endDate: String;
  tasks: String[];
}

export interface JobPreviousValuesPromise
  extends Promise<JobPreviousValues>,
    Fragmentable {
  position: () => Promise<String>;
  company: () => Promise<String>;
  location: () => Promise<String>;
  startDate: () => Promise<String>;
  endDate: () => Promise<String>;
  tasks: () => Promise<String[]>;
}

export interface JobPreviousValuesSubscription
  extends Promise<AsyncIterator<JobPreviousValues>>,
    Fragmentable {
  position: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<String>>;
  endDate: () => Promise<AsyncIterator<String>>;
  tasks: () => Promise<AsyncIterator<String[]>>;
}

export interface LanguageSubscriptionPayload {
  mutation: MutationType;
  node: Language;
  updatedFields: String[];
  previousValues: LanguagePreviousValues;
}

export interface LanguageSubscriptionPayloadPromise
  extends Promise<LanguageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LanguagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LanguagePreviousValuesPromise>() => T;
}

export interface LanguageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LanguageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LanguageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LanguagePreviousValuesSubscription>() => T;
}

export interface LanguagePreviousValues {
  language: String;
  level: String;
}

export interface LanguagePreviousValuesPromise
  extends Promise<LanguagePreviousValues>,
    Fragmentable {
  language: () => Promise<String>;
  level: () => Promise<String>;
}

export interface LanguagePreviousValuesSubscription
  extends Promise<AsyncIterator<LanguagePreviousValues>>,
    Fragmentable {
  language: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<String>>;
}

export interface ResumeSubscriptionPayload {
  mutation: MutationType;
  node: Resume;
  updatedFields: String[];
  previousValues: ResumePreviousValues;
}

export interface ResumeSubscriptionPayloadPromise
  extends Promise<ResumeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ResumePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ResumePreviousValuesPromise>() => T;
}

export interface ResumeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ResumeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ResumeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ResumePreviousValuesSubscription>() => T;
}

export interface ResumePreviousValues {
  id: ID_Output;
  urlSlug: String;
  themeColor: String;
}

export interface ResumePreviousValuesPromise
  extends Promise<ResumePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  urlSlug: () => Promise<String>;
  themeColor: () => Promise<String>;
}

export interface ResumePreviousValuesSubscription
  extends Promise<AsyncIterator<ResumePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  urlSlug: () => Promise<AsyncIterator<String>>;
  themeColor: () => Promise<AsyncIterator<String>>;
}

export interface SkillSubscriptionPayload {
  mutation: MutationType;
  node: Skill;
  updatedFields: String[];
  previousValues: SkillPreviousValues;
}

export interface SkillSubscriptionPayloadPromise
  extends Promise<SkillSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SkillPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SkillPreviousValuesPromise>() => T;
}

export interface SkillSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SkillSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SkillSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SkillPreviousValuesSubscription>() => T;
}

export interface SkillPreviousValues {
  name: String;
  level: Float;
}

export interface SkillPreviousValuesPromise
  extends Promise<SkillPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  level: () => Promise<Float>;
}

export interface SkillPreviousValuesSubscription
  extends Promise<AsyncIterator<SkillPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<Float>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Resume",
    embedded: false
  },
  {
    name: "General",
    embedded: false
  },
  {
    name: "Language",
    embedded: false
  },
  {
    name: "Hobby",
    embedded: false
  },
  {
    name: "Skill",
    embedded: false
  },
  {
    name: "Job",
    embedded: false
  },
  {
    name: "Education",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
